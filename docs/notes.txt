utils
    pbkdf2
    _slow_bcrypt
    _slow_unix_crypt

unix
    unix_crypt
    ext_unix_crypt
    md5_crypt
    pbkdf2_dlitz
    bcrypt
    sha256_crypt
    sha512_crypt

    linux_context
    bsd_context
    default_context

mysql
    mysql_10
    mysql_41

    mysql_context
    mysql_10_context

postgres
    postgres_md5

    postgres_context

grub
    md5_crypt
    grub_pbkdf2_sha512

    grub_context
=====================================

utils
    pbkdf2
    _slow_bcrypt
    _slow_unix_crypt

unix
    unix_crypt/
        unix_crypt
        ext_unix_crypt
    md5_crypt/
        md5_crypt
    pbkdf2_dlitz/
        pbkdf2_dlitz
    bcrypt/
        bcrypt
    sha_crypt/
        sha256_crypt
        sha512_crypt

    linux_context
    bsd_context
    default_context

mysql
    mysql_10
    mysql_41

    mysql_context
    mysql_10_context

postgres
    postgres_md5

    postgres_context

grub
    md5_crypt
    grub_pbkdf2_sha512

    grub_context

======================

required public attributes

    name
        unique name used to identify this algorithm within passlib.

    context_kwds

        tuple identifying any arguments which must be provided in addition
        to secret in order to encrypt / verify a hash.

        eg: postgres_md5 requires the username to be provided to encrypt & verify,
        and so context_args is set to ``("user",)``.

        this tuple is empty for most algorithms.

    setting_kwds

        tuple identifying encrypt() kwds that can be used to configure
        output. common kwds include ``salt`` and ``rounds``.

optional public attributes

    secret_chars
        Indicates maximum number of characters used by algorithm.

        This will be ``-1`` for most algorithm, indicating they use incorporate
        the whole secret into the resulting hash.

        For example: ``unix-crypt`` only considers the first 8 characters in a password.

        Provided for user information, and for use by the passlib unittests.

    salt_bytes
        Indicates number of bytes in salt portion of hash
        after decoding. 0 to indicate algorithm has no salt.

       Provided for user information, and for use by the passlib unittests.

    hash_bytes
        Indicates number of bytes in checksum portion of hash
        after decoding. 0 to indicate algorithm has no salt.

       Provided for user information, and for use by the passlib unittests.

    default_rounds
        if the algorithm supports variable number of rounds,
        this should indicate the default number of rounds that will be used
        if none is specified when encrypt() is called.

    min_rounds
        if the algorithm supports variable number of rounds,
        this should indicate the minimum number it will accept.
        values below this will silently use minimum instead.

    max_rounds
        if the algorithm supports variable number of rounds,
        this should indicate the maximum number it will accept.
        values above this will silently use maximum instead.

required public methods

    encrypt(secret, **context_kwds, **settings_kwds) -> hash
        ValueError if settings out of bounds
        should handle unicode secrets (not implemented for all hashes yet)

    verify(secret, hash, **context_kwds) -> True | False
        ValueError if hash empty or not recognized by hash

optional public methods

    identify(hash) -> True | False
        return True hash defined & matches algorithm
        returns False otherwise

    parse(hash) -> dict
        parses existing hash into a dict of component parts.
        raises ValueError if hash is not defined or doesn't match algorithm format.

        common keywords include ``ident``, ``salt``, ``rounds``, and ``checksum``.

        any keywords in this dictionary which are listed in ``setting_kwds``
        can usually be passed into encrypt to generate a new hash with the same settings.

        XXX: would it work to require that kwds of dict returned by parse
        must be in setting_kwds + (optionally) "checksum"?

    render(**parse_kwds) -> str
        takes kwds as returned by parse() method,
        and returns resulting hash.

        should generally act as the inverse of parse().

======================================================================
info about upgrade policy scheme, and sun-md5 ref...
    http://www.cuddletech.com/blog/pivot/entry.php?id=778

some sample hashes all using "passwd", including sunmd5
    http://compgroups.net/comp.unix.solaris/password-file-in-linux-and-solaris-8-9

nt-hash
    md4.new(passwd.encode('utf-16le')).hexdigest().upper()

    mygreatpasswd
    CFACF72F5EB60EA15F89E3AF66732545

    http://www.faqs.org/rfcs/rfc1320.html

    $3$hash


http://search.cpan.org/~zefram/Authen-Passphrase-0.007/lib/Authen/Passphrase.pm
======================================================================
OS notes

    summary from http://www.dribin.org/dave/blog/archives/2006/04/28/os_x_passwords_2/

osx < 10.2 used /etc/passwd w/ DES-CRYPT

osx 10.3 hash file (passwd "macintosh")

D47F3AF827A48F7DFA4F2C1F12D68CD6 <-- nthash
08460EB13C5CA0C4CA9516712F7FED95 <-- lmhash
01424f955c11f92efef0b79d7fa3fb6be56a9f99 <-- sha1

osx 10.4 hash file (passwd "macintosh")
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
000000000E6A48F765D0FFFFF6247FA80D748E615F91DD0C7431E4D9000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000

offset 0-64 - nt hash + lm hash OR all zeros
offset 64 - 40 chars - raw sha1 password OR all zeroes (if from upgraded from 10.3)
offset 169-216 ( 48 chars) - salted sha1 hash - unhex first 8 chars + password | sha1 -> hexdigest



======================


policy file format

[passlib.policy]
des-crypt:decpreated = true
sha512-crypt:default-rounds = 40000
sha512-crypt:min-rounds = 30000
sha512-crypt:max-rounds = 50000
